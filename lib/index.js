// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, Helpers, ResqueScheduler,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  Helpers = {
    timestamp: function(val) {
      return Math.floor(this.getTime(val));
    },
    getTime: function(val) {
      if (this.isDate(val)) {
        return val.getTime() / 1000;
      } else if (this.isNumber(val)) {
        return val / 1000;
      } else {
        throw "Invalid timestamp provide. Should be either a Date object or a number.";
      }
    },
    isDate: function(val) {
      return '[object Date]' === toString.apply(val);
    },
    isNumber: function(val) {
      return typeof val === 'number' && isFinite(val);
    }
  };

  ResqueScheduler = (function(_super) {
    __extends(ResqueScheduler, _super);

    function ResqueScheduler(resque) {
      this.resque = resque;
      this.redis = this.resque.redis;
      this.running = false;
    }

    ResqueScheduler.prototype.enqueueAt = function(queue, future, command, args) {
      var job;
      job = JSON.stringify({
        "class": command,
        queue: queue,
        args: args || []
      });
      return this.delayDelivery(future, job);
    };

    ResqueScheduler.prototype.enqueueIn = function(queue, secondsFromNow, command, args) {
      var future;
      future = this.now() + secondsFromNow * 1000;
      return this.enqueueAt(queue, future, command, args);
    };

    ResqueScheduler.prototype.delayDelivery = function(future, job) {
      var multi;
      future = Helpers.timestamp(future);
      multi = this.redis.multi();
      multi.rpush(this.resque.key("delayed:" + future), job);
      multi.zadd(this.resque.key('delayed_queue_schedule'), future, future);
      return multi.exec();
    };

    ResqueScheduler.prototype.start = function() {
      if (this.running) {
        return;
      }
      this.running = true;
      return this.poll();
    };

    ResqueScheduler.prototype.end = function() {
      return this.running = false;
    };

    ResqueScheduler.prototype.poll = function() {
      var time,
        _this = this;
      time = Helpers.timestamp(this.now());
      return this.nextDelayedTimestamp(time, function(timestamp) {
        if (timestamp) {
          return _this.deliverJobs(timestamp, function() {
            return _this.poll();
          });
        } else {
          return _this.pause();
        }
      });
    };

    ResqueScheduler.prototype.pause = function() {
      var _this = this;
      return setTimeout(function() {
        if (!_this.running) {
          return;
        }
        return _this.poll();
      }, 1000);
    };

    ResqueScheduler.prototype.nextDelayedTimestamp = function(time, callback) {
      var key;
      key = this.resque.key('delayed_queue_schedule');
      return this.redis.zrangebyscore(key, '-inf', time, 'limit', 0, 1, function(err, items) {
        return callback(items[0]);
      });
    };

    ResqueScheduler.prototype.deliverJobs = function(timestamp, callback) {
      var _this = this;
      return this.jobsForDelivery(timestamp, function(jobs) {
        var job, _i, _len;
        for (_i = 0, _len = jobs.length; _i < _len; _i++) {
          job = jobs[_i];
          _this.deliver(job);
        }
        return callback();
      });
    };

    ResqueScheduler.prototype.jobsForDelivery = function(timestamp, callback) {
      var key,
        _this = this;
      key = this.resque.key("delayed:" + timestamp);
      return this.redis.lrange(key, 0, -1, function(err, jobs) {
        return _this.cleanup(timestamp, function() {
          var job, result, _i, _len;
          result = [];
          for (_i = 0, _len = jobs.length; _i < _len; _i++) {
            job = jobs[_i];
            result.push(JSON.parse(job));
          }
          return callback(result);
        });
      });
    };

    ResqueScheduler.prototype.deliver = function(job) {
      return this.resque.enqueue(job.queue, job["class"], job.args);
    };

    ResqueScheduler.prototype.cleanup = function(timestamp, callback) {
      var key, multi;
      key = this.resque.key("delayed:" + timestamp);
      multi = this.redis.multi();
      multi.del(key);
      multi.zrem(this.resque.key('delayed_queue_schedule'), timestamp);
      return multi.exec(function() {
        return callback();
      });
    };

    ResqueScheduler.prototype.now = function() {
      return new Date().getTime();
    };

    return ResqueScheduler;

  })(EventEmitter);

  exports.schedulerUsing = function(Resque) {
    return new exports.ResqueScheduler(Resque || {});
  };

  exports.ResqueScheduler = ResqueScheduler;

}).call(this);
